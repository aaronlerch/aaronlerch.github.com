<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Aaron Lerch]]></title>
  <link href="http://aaronlerch.github.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://aaronlerch.github.com/"/>
  <updated>2012-01-14T23:31:46-05:00</updated>
  <id>http://aaronlerch.github.com/</id>
  <author>
    <name><![CDATA[Aaron Lerch]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[App Extensibility, Follow Up]]></title>
    <link href="http://aaronlerch.github.com/blog/2011/10/09/app-extensibility/"/>
    <updated>2011-10-09T22:35:00-04:00</updated>
    <id>http://aaronlerch.github.com/blog/2011/10/09/app-extensibility</id>
    <content type="html"><![CDATA[<p>My <a href="http://aaronlerch.github.com/blog/2011/09/08/app-extensibility-in-ruby/">last post</a> about introducing an extensibility point
got some good feedback. I realized two things:</p>

<ol>
<li>Following the pattern of rails generators was <em>huge</em> overkill</li>
<li>I wasn't thinking correctly about the problem to begin with</li>
</ol>


<p>Rails generators need to support a lot of things. For example, they
need to process command line arguments, consume or produce templates, and update
existing files in a non-destructive way. The potential complexity in
generators is handled by the complexity in the extensility model
implemented in rails. Arbitrarily duplicating this complexity (magic class names,
inheritance, etc) is just wrong. Which, of course, is why I
said:</p>

<blockquote><p>OK, Iâ€™m doing something wrong, I just know it</p></blockquote>

<p>If I was going to continue down this road (I'm not, see below) I would
take a cue from something like <a href="http://www.sinatrarb.com/">Sinatra</a> and take advantage
of global methods to reduce/remove requirements on the configuration
code.</p>

<p><code>ruby
configure do |host|
  # do something with 'host' to configure your app
end
</code></p>

<p>But that's all irrelevent. Jeff Lindsay set me straight in a comment on my
previous post.</p>

<blockquote><p>The hooks that most SCM use, like post-commit or post-receive,
are based on running shell scripts. This is my favorite approach
so far because it's not language specific.</p></blockquote>

<p>DUH. I love those things that I look back and think "of course."</p>

<p>I was thinking about this as a ruby problem, because localtunnel's
client is written in ruby. But it's not a ruby problem. Localtunnel is a
utility. I can write hooks for Git in anything I want, it doesn't matter
what language Git is written in. The same is true for localtunnel.</p>

<p>Taking this approach <em>greatly</em> simplifies the solution. And the simpler
solution is always always always the better solution. In this
case, we can add a quick check followed by a system call to enable users
to provide a shell hook to configure whatever system(s) they want:</p>

<p>``` ruby
SHELL_HOOK_FILE = "./.localtunnel_callback"</p>

<p>...</p>

<p>if File.exists?(File.expand_path(SHELL_HOOK_FILE))
  system "#{SHELL_HOOK_FILE} ""#{tunnel['host']}""" if File.exists?(File.expand_path(SHELL_HOOK_FILE))
  if !$?.success?</p>

<pre><code>puts "   An error occurred executing the callback hook #{SHELL_HOOK_FILE}"
puts "   (Make sure it is executable)"
</code></pre>

<p>  end
end
```</p>

<p>Bam. Localtunnel now provides an extensibility point that can be
implemented in any language. Well, it will when/if my <a href="https://github.com/progrium/localtunnel/pull/27">pull request</a> is
accepted. :)</p>

<p>Thanks, Jeff!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[App Extensibility in Ruby]]></title>
    <link href="http://aaronlerch.github.com/blog/2011/09/08/app-extensibility-in-ruby/"/>
    <updated>2011-09-08T18:13:00-04:00</updated>
    <id>http://aaronlerch.github.com/blog/2011/09/08/app-extensibility-in-ruby</id>
    <content type="html"><![CDATA[<p>I ran into an interesting problem recently. There is a utility
called <a href="http://progrium.com/localtunnel/" title="LocalTunnel is sweet">localtunnel</a> which connects a public URL to a local port. Extremely
useful when it comes to developing an app that leverages services that
expose web hooks.</p>

<p>The problem is that the public URL is only valid while the script is running. Which means every time you start it, you potentially need to go update the web hook URL in whatever service you're using. For example, with <a href="http://www.twilio.com/" title="Twilio is awesomesauce">Twilio</a> you configure an app that is available at a particular URL. With GitHub you can add <a href="http://help.github.com/post-receive-hooks/" title="Docs at GitHub">post-receive hooks</a>.</p>

<p>What needs to happen is that localtunnel needs to give you a chance to run some
custom code after it registers and connects up ports, but before it sits
and waits.</p>

<p>It needs an extension point.</p>

<p><a href="https://github.com/snay2/localtunnel/">One fork</a> seeks to do this by having localtunnel call a web hook. It works, even if it feels a bit ironic. ;)
But that involves maintaining another service simply to configure your
first service, which is less than ideal. I took a different approach and I'd love to get feedback here, since I'm
still so new to this.</p>

<p>Most stuff on the web about extending ruby has to do with class design,
or monkeypatching, or something else that assumes all the code is
already loaded and executing. In this case, there's an existing app (not framework)
and I want to have it load <em>my</em> code dynamically at runtime. In my code,
I want to configure whatever service I need to.</p>

<p>Being a n00b, I'm not the most widely read yet, so I looked at an
example of something that I already knew exposed an extension point in a
similar way: <a href="http://guides.rubyonrails.org/generators.html">rails generators</a>.</p>

<p><a href="https://github.com/progrium/localtunnel/pull/23">You can see my code here</a>
and the <a href="https://github.com/aaronlerch/localtunnel/">updated readme here</a>,
but here's how it works.</p>

<h2>Specify the config to run</h2>

<p>This part was easy, I just extended the existing command line processing
to add a "-c NAME" argument specifying which configuration you want to run.
For example:</p>

<p><code>
$ localtunnel -c twilio 9292
</code></p>

<p>will create a public URL connecting to local port 9292, and will look
for an auto configuration implementation named "twilio" and execute it.</p>

<h2>Discovery via magic names, I mean, convention</h2>

<p>This is a nice, but sometimes frustrating thing about Rails. There's
lots of stuff that magically happens if you organize or name your code a
certain way.</p>

<p>In this case, to make it easy to specify via the command line, I opted
for a similar "magic name" approach. Name your file
foo_auto_config.rb and when you specify "-c foo" I'll look for your
file under a 'localtunnel' subdir. This is a way to try and avoid loading a lot of code unnecessarily.</p>

<p>``` ruby Discover files by name https://github.com/aaronlerch/localtunnel/blob/master/lib/localtunnel/autoconfig.rb
def self.lookup(name)
  including_current = $LOAD_PATH.dup
  including_current &lt;&lt; '.'
  including_current.each do |base|</p>

<pre><code>Dir[File.join(base, "localtunnel", "#{name}_auto_config.rb")].each do |path|
  begin
    require path
  rescue Exception =&gt; e
    puts "   [Warning] Could not load autoconfig #{path.inspect}. Error: #{e.message}.\n#{e.backtrace.join("\n")}"
  end
end
</code></pre>

<p>  end
end
```</p>

<p>This has a few issues with it. Because this is running as a script, if
you're using bundler, the $LOAD_PATH won't include all the gems unless
Bundler.require has been called. So looking in the load path for auto
configuration files is probably pointless. Not that gems would include a
custom auto configuration anyway. I should probably remove this.
(Thoughts?) Secondly, I manually added
the local directory because ruby 1.9.2 <a href="http://stackoverflow.com/questions/2900370/why-does-ruby-1-9-2-remove-from-load-path-and-whats-the-alternative">took it out of $LOAD_PATH by default</a> due to security reasons.
And if you consider the use-case, this is typically executed from within
~/MyApp and not randomly throughout the directory structure. Again,
similar to rails generators, you run it from the root of your
application directory.</p>

<h2>Discovery via class name + base class</h2>

<p>Now that we've figured out which files to load, we still don't know what
code to call. We need to be able to pass in parameters such as the new
URL that is reserved, so we probably want a method to call and not just loading a file.</p>

<p>Ruby gives us a feature that allows you to know when a new base class is
created: the <a href="http://www.ruby-doc.org/core/classes/Class.html#M000177">inherited</a> method.
It gets called when a new subclass is created.</p>

<p>I created a base class, LocalTunnel::AutoConfig::Base, which keeps track
of all subclasses:</p>

<p>``` ruby Collect all subclasses into an array https://github.com/aaronlerch/localtunnel/blob/master/lib/localtunnel/autoconfig.rb
class Base
  def self.inherited(base)</p>

<pre><code>super

if base.name &amp;&amp; base.name !~ /Base$/
  LocalTunnel::AutoConfig.subclasses &lt;&lt; base
end
</code></pre>

<p>  end
end
```</p>

<p>When someone specifies "-c foo" on the command line, I look for any
subclass of LocalTunnel::AutoConfig::Base that is named FooAutoConfig
and has a method called "configure". If I find that, then that's the
auto configuration code that will be called.</p>

<p>``` ruby Find the right class https://github.com/aaronlerch/localtunnel/blob/master/lib/localtunnel/autoconfig.rb
def self.find(name)
  lookup(name)</p>

<p>  names = Hash[subclasses.map { |klass| [autoconfig_name(klass).downcase, klass] }]
  klass = names[name]
  return nil if klass.nil?</p>

<p>  configurator = klass.new
  if configurator.respond_to? :configure</p>

<pre><code>configurator
</code></pre>

<p>  else</p>

<pre><code>nil
</code></pre>

<p>  end
end
```</p>

<p>Then I can call that method on an instance of the matching class, and
pass it the new URL.</p>

<p>``` ruby Call the configuration class https://github.com/aaronlerch/localtunnel/blob/master/lib/localtunnel/tunnel.rb
if !@autoconfig.nil?
  configurator = LocalTunnel::AutoConfig.find(@autoconfig)
  if configurator</p>

<pre><code>configurator.configure(tunnel['host'])
</code></pre>

<p>  else</p>

<pre><code>puts "   [Warning] Unable to find an automatic configuration plugin for '#{@autoconfig}'"
</code></pre>

<p>  end
end
```</p>

<h2>Do your custom configuration</h2>

<p>The configuration code can then run and do whatever it wants. Usually it's
specific per app. Here's an example of me using this to configure
Twilio.</p>

<p>``` ruby twilio_auto_config.rb
require 'rubygems'
require 'localtunnel/autoconfig'
require 'twilio-ruby'
require 'uri'</p>

<p>class TwilioAutoConfig &lt; LocalTunnel::AutoConfig::Base</p>

<p>  TWILIO_ACCOUNT_SID = # my account Sid
  TWILIO_AUTH_TOKEN = ENV['TWILIO_AUTH_TOKEN']
  TWILIO_APP_SID = ENV['TWILIO_APP_SID']</p>

<p>  def configure(host)</p>

<pre><code># set up a client to talk to the Twilio REST API
client = Twilio::REST::Client.new(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN)
app = client.account.applications.get(TWILIO_APP_SID)

# Grab the current voice_url and status_callback and swap out the host
voice = URI.parse(app.voice_url)
voice.host = host
status_callback = URI.parse(app.status_callback)
status_callback.host = host

app.update({:voice_url =&gt; voice.to_s, :status_callback =&gt; status_callback.to_s})
puts "   Configured twilio app #{app.friendly_name} for new host #{host}"
</code></pre>

<p>  end
end
```</p>

<h2>OK, I'm doing something wrong, I just know it</h2>

<p>I am sure I either overcomplicated this, or just plain did it wrong.
Some thoughts I have (in hindsight now) are that perhaps I could've
exposed a global method for the autoconfig code to call. Then, instead
of a base class and magic class name, I'd just load the specified file
(magic name is still nice) and in that file I could call "host" to get
the new host name.</p>

<p>Leave a comment, create a gist, <a href="https://github.com/aaronlerch/localtunnel/">fork my fork</a>,
or <a href="http://twitter.com/aaronlerch/">tweet at me</a>, but somehow let me know how I could
make this better.</p>
]]></content>
  </entry>
  
</feed>
